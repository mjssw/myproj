// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tetris.proto

#ifndef PROTOBUF_tetris_2eproto__INCLUDED
#define PROTOBUF_tetris_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "public.pb.h"
// @@protoc_insertion_point(includes)

namespace sglib {
namespace tetrisproto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tetris_2eproto();
void protobuf_AssignDesc_tetris_2eproto();
void protobuf_ShutdownFile_tetris_2eproto();

class CSMsgReadyReq;
class SCMsgReadyRsp;
class SCMsgReadyNtf;
class CSMsgGameLostReq;
class SCMsgGameStartNtf;
class SCMsgGameEndNtf;
class CSMsgPutBlockReq;
class CSMsgClearBlockReq;
class SCMsgPutBlockNtf;
class SCMsgClearBlockNtf;
class SCMsgRoomInfoNtf;

// ===================================================================

class CSMsgReadyReq : public ::google::protobuf::Message {
 public:
  CSMsgReadyReq();
  virtual ~CSMsgReadyReq();

  CSMsgReadyReq(const CSMsgReadyReq& from);

  inline CSMsgReadyReq& operator=(const CSMsgReadyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgReadyReq& default_instance();

  void Swap(CSMsgReadyReq* other);

  // implements Message ----------------------------------------------

  CSMsgReadyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgReadyReq& from);
  void MergeFrom(const CSMsgReadyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.CSMsgReadyReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static CSMsgReadyReq* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgReadyRsp : public ::google::protobuf::Message {
 public:
  SCMsgReadyRsp();
  virtual ~SCMsgReadyRsp();

  SCMsgReadyRsp(const SCMsgReadyRsp& from);

  inline SCMsgReadyRsp& operator=(const SCMsgReadyRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgReadyRsp& default_instance();

  void Swap(SCMsgReadyRsp* other);

  // implements Message ----------------------------------------------

  SCMsgReadyRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgReadyRsp& from);
  void MergeFrom(const SCMsgReadyRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgReadyRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgReadyRsp* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgReadyNtf : public ::google::protobuf::Message {
 public:
  SCMsgReadyNtf();
  virtual ~SCMsgReadyNtf();

  SCMsgReadyNtf(const SCMsgReadyNtf& from);

  inline SCMsgReadyNtf& operator=(const SCMsgReadyNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgReadyNtf& default_instance();

  void Swap(SCMsgReadyNtf* other);

  // implements Message ----------------------------------------------

  SCMsgReadyNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgReadyNtf& from);
  void MergeFrom(const SCMsgReadyNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string player = 1;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 1;
  inline const ::std::string& player() const;
  inline void set_player(const ::std::string& value);
  inline void set_player(const char* value);
  inline void set_player(const char* value, size_t size);
  inline ::std::string* mutable_player();
  inline ::std::string* release_player();
  inline void set_allocated_player(::std::string* player);

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgReadyNtf)
 private:
  inline void set_has_player();
  inline void clear_has_player();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* player_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgReadyNtf* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgGameLostReq : public ::google::protobuf::Message {
 public:
  CSMsgGameLostReq();
  virtual ~CSMsgGameLostReq();

  CSMsgGameLostReq(const CSMsgGameLostReq& from);

  inline CSMsgGameLostReq& operator=(const CSMsgGameLostReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgGameLostReq& default_instance();

  void Swap(CSMsgGameLostReq* other);

  // implements Message ----------------------------------------------

  CSMsgGameLostReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgGameLostReq& from);
  void MergeFrom(const CSMsgGameLostReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.CSMsgGameLostReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static CSMsgGameLostReq* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgGameStartNtf : public ::google::protobuf::Message {
 public:
  SCMsgGameStartNtf();
  virtual ~SCMsgGameStartNtf();

  SCMsgGameStartNtf(const SCMsgGameStartNtf& from);

  inline SCMsgGameStartNtf& operator=(const SCMsgGameStartNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgGameStartNtf& default_instance();

  void Swap(SCMsgGameStartNtf* other);

  // implements Message ----------------------------------------------

  SCMsgGameStartNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgGameStartNtf& from);
  void MergeFrom(const SCMsgGameStartNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 blockseed = 1;
  inline bool has_blockseed() const;
  inline void clear_blockseed();
  static const int kBlockseedFieldNumber = 1;
  inline ::google::protobuf::int32 blockseed() const;
  inline void set_blockseed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgGameStartNtf)
 private:
  inline void set_has_blockseed();
  inline void clear_has_blockseed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blockseed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgGameStartNtf* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgGameEndNtf : public ::google::protobuf::Message {
 public:
  SCMsgGameEndNtf();
  virtual ~SCMsgGameEndNtf();

  SCMsgGameEndNtf(const SCMsgGameEndNtf& from);

  inline SCMsgGameEndNtf& operator=(const SCMsgGameEndNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgGameEndNtf& default_instance();

  void Swap(SCMsgGameEndNtf* other);

  // implements Message ----------------------------------------------

  SCMsgGameEndNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgGameEndNtf& from);
  void MergeFrom(const SCMsgGameEndNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string loser = 1;
  inline bool has_loser() const;
  inline void clear_loser();
  static const int kLoserFieldNumber = 1;
  inline const ::std::string& loser() const;
  inline void set_loser(const ::std::string& value);
  inline void set_loser(const char* value);
  inline void set_loser(const char* value, size_t size);
  inline ::std::string* mutable_loser();
  inline ::std::string* release_loser();
  inline void set_allocated_loser(::std::string* loser);

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgGameEndNtf)
 private:
  inline void set_has_loser();
  inline void clear_has_loser();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* loser_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgGameEndNtf* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgPutBlockReq : public ::google::protobuf::Message {
 public:
  CSMsgPutBlockReq();
  virtual ~CSMsgPutBlockReq();

  CSMsgPutBlockReq(const CSMsgPutBlockReq& from);

  inline CSMsgPutBlockReq& operator=(const CSMsgPutBlockReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgPutBlockReq& default_instance();

  void Swap(CSMsgPutBlockReq* other);

  // implements Message ----------------------------------------------

  CSMsgPutBlockReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgPutBlockReq& from);
  void MergeFrom(const CSMsgPutBlockReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 blockid = 1;
  inline bool has_blockid() const;
  inline void clear_blockid();
  static const int kBlockidFieldNumber = 1;
  inline ::google::protobuf::int32 blockid() const;
  inline void set_blockid(::google::protobuf::int32 value);

  // required int32 column = 2;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline ::google::protobuf::int32 column() const;
  inline void set_column(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.CSMsgPutBlockReq)
 private:
  inline void set_has_blockid();
  inline void clear_has_blockid();
  inline void set_has_column();
  inline void clear_has_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blockid_;
  ::google::protobuf::int32 column_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static CSMsgPutBlockReq* default_instance_;
};
// -------------------------------------------------------------------

class CSMsgClearBlockReq : public ::google::protobuf::Message {
 public:
  CSMsgClearBlockReq();
  virtual ~CSMsgClearBlockReq();

  CSMsgClearBlockReq(const CSMsgClearBlockReq& from);

  inline CSMsgClearBlockReq& operator=(const CSMsgClearBlockReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSMsgClearBlockReq& default_instance();

  void Swap(CSMsgClearBlockReq* other);

  // implements Message ----------------------------------------------

  CSMsgClearBlockReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSMsgClearBlockReq& from);
  void MergeFrom(const CSMsgClearBlockReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 rows = 1;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::int32 rows(int index) const;
  inline void set_rows(int index, ::google::protobuf::int32 value);
  inline void add_rows(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rows() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.CSMsgClearBlockReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rows_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static CSMsgClearBlockReq* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgPutBlockNtf : public ::google::protobuf::Message {
 public:
  SCMsgPutBlockNtf();
  virtual ~SCMsgPutBlockNtf();

  SCMsgPutBlockNtf(const SCMsgPutBlockNtf& from);

  inline SCMsgPutBlockNtf& operator=(const SCMsgPutBlockNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgPutBlockNtf& default_instance();

  void Swap(SCMsgPutBlockNtf* other);

  // implements Message ----------------------------------------------

  SCMsgPutBlockNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgPutBlockNtf& from);
  void MergeFrom(const SCMsgPutBlockNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 blockid = 1;
  inline bool has_blockid() const;
  inline void clear_blockid();
  static const int kBlockidFieldNumber = 1;
  inline ::google::protobuf::int32 blockid() const;
  inline void set_blockid(::google::protobuf::int32 value);

  // required int32 column = 2;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline ::google::protobuf::int32 column() const;
  inline void set_column(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgPutBlockNtf)
 private:
  inline void set_has_blockid();
  inline void clear_has_blockid();
  inline void set_has_column();
  inline void clear_has_column();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blockid_;
  ::google::protobuf::int32 column_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgPutBlockNtf* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgClearBlockNtf : public ::google::protobuf::Message {
 public:
  SCMsgClearBlockNtf();
  virtual ~SCMsgClearBlockNtf();

  SCMsgClearBlockNtf(const SCMsgClearBlockNtf& from);

  inline SCMsgClearBlockNtf& operator=(const SCMsgClearBlockNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgClearBlockNtf& default_instance();

  void Swap(SCMsgClearBlockNtf* other);

  // implements Message ----------------------------------------------

  SCMsgClearBlockNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgClearBlockNtf& from);
  void MergeFrom(const SCMsgClearBlockNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 rows = 1;
  inline int rows_size() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 1;
  inline ::google::protobuf::int32 rows(int index) const;
  inline void set_rows(int index, ::google::protobuf::int32 value);
  inline void add_rows(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rows() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rows();

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgClearBlockNtf)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rows_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgClearBlockNtf* default_instance_;
};
// -------------------------------------------------------------------

class SCMsgRoomInfoNtf : public ::google::protobuf::Message {
 public:
  SCMsgRoomInfoNtf();
  virtual ~SCMsgRoomInfoNtf();

  SCMsgRoomInfoNtf(const SCMsgRoomInfoNtf& from);

  inline SCMsgRoomInfoNtf& operator=(const SCMsgRoomInfoNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SCMsgRoomInfoNtf& default_instance();

  void Swap(SCMsgRoomInfoNtf* other);

  // implements Message ----------------------------------------------

  SCMsgRoomInfoNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SCMsgRoomInfoNtf& from);
  void MergeFrom(const SCMsgRoomInfoNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sglib.publicproto.RoomPlayerInfo players = 1;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 1;
  inline const ::sglib::publicproto::RoomPlayerInfo& players(int index) const;
  inline ::sglib::publicproto::RoomPlayerInfo* mutable_players(int index);
  inline ::sglib::publicproto::RoomPlayerInfo* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::sglib::publicproto::RoomPlayerInfo >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::sglib::publicproto::RoomPlayerInfo >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:sglib.tetrisproto.SCMsgRoomInfoNtf)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sglib::publicproto::RoomPlayerInfo > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_tetris_2eproto();
  friend void protobuf_AssignDesc_tetris_2eproto();
  friend void protobuf_ShutdownFile_tetris_2eproto();

  void InitAsDefaultInstance();
  static SCMsgRoomInfoNtf* default_instance_;
};
// ===================================================================


// ===================================================================

// CSMsgReadyReq

// -------------------------------------------------------------------

// SCMsgReadyRsp

// required int32 result = 1;
inline bool SCMsgReadyRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCMsgReadyRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCMsgReadyRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCMsgReadyRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 SCMsgReadyRsp::result() const {
  return result_;
}
inline void SCMsgReadyRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SCMsgReadyNtf

// required string player = 1;
inline bool SCMsgReadyNtf::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCMsgReadyNtf::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCMsgReadyNtf::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCMsgReadyNtf::clear_player() {
  if (player_ != &::google::protobuf::internal::kEmptyString) {
    player_->clear();
  }
  clear_has_player();
}
inline const ::std::string& SCMsgReadyNtf::player() const {
  return *player_;
}
inline void SCMsgReadyNtf::set_player(const ::std::string& value) {
  set_has_player();
  if (player_ == &::google::protobuf::internal::kEmptyString) {
    player_ = new ::std::string;
  }
  player_->assign(value);
}
inline void SCMsgReadyNtf::set_player(const char* value) {
  set_has_player();
  if (player_ == &::google::protobuf::internal::kEmptyString) {
    player_ = new ::std::string;
  }
  player_->assign(value);
}
inline void SCMsgReadyNtf::set_player(const char* value, size_t size) {
  set_has_player();
  if (player_ == &::google::protobuf::internal::kEmptyString) {
    player_ = new ::std::string;
  }
  player_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCMsgReadyNtf::mutable_player() {
  set_has_player();
  if (player_ == &::google::protobuf::internal::kEmptyString) {
    player_ = new ::std::string;
  }
  return player_;
}
inline ::std::string* SCMsgReadyNtf::release_player() {
  clear_has_player();
  if (player_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_;
    player_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SCMsgReadyNtf::set_allocated_player(::std::string* player) {
  if (player_ != &::google::protobuf::internal::kEmptyString) {
    delete player_;
  }
  if (player) {
    set_has_player();
    player_ = player;
  } else {
    clear_has_player();
    player_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMsgGameLostReq

// -------------------------------------------------------------------

// SCMsgGameStartNtf

// required int32 blockseed = 1;
inline bool SCMsgGameStartNtf::has_blockseed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCMsgGameStartNtf::set_has_blockseed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCMsgGameStartNtf::clear_has_blockseed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCMsgGameStartNtf::clear_blockseed() {
  blockseed_ = 0;
  clear_has_blockseed();
}
inline ::google::protobuf::int32 SCMsgGameStartNtf::blockseed() const {
  return blockseed_;
}
inline void SCMsgGameStartNtf::set_blockseed(::google::protobuf::int32 value) {
  set_has_blockseed();
  blockseed_ = value;
}

// -------------------------------------------------------------------

// SCMsgGameEndNtf

// required string loser = 1;
inline bool SCMsgGameEndNtf::has_loser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCMsgGameEndNtf::set_has_loser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCMsgGameEndNtf::clear_has_loser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCMsgGameEndNtf::clear_loser() {
  if (loser_ != &::google::protobuf::internal::kEmptyString) {
    loser_->clear();
  }
  clear_has_loser();
}
inline const ::std::string& SCMsgGameEndNtf::loser() const {
  return *loser_;
}
inline void SCMsgGameEndNtf::set_loser(const ::std::string& value) {
  set_has_loser();
  if (loser_ == &::google::protobuf::internal::kEmptyString) {
    loser_ = new ::std::string;
  }
  loser_->assign(value);
}
inline void SCMsgGameEndNtf::set_loser(const char* value) {
  set_has_loser();
  if (loser_ == &::google::protobuf::internal::kEmptyString) {
    loser_ = new ::std::string;
  }
  loser_->assign(value);
}
inline void SCMsgGameEndNtf::set_loser(const char* value, size_t size) {
  set_has_loser();
  if (loser_ == &::google::protobuf::internal::kEmptyString) {
    loser_ = new ::std::string;
  }
  loser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SCMsgGameEndNtf::mutable_loser() {
  set_has_loser();
  if (loser_ == &::google::protobuf::internal::kEmptyString) {
    loser_ = new ::std::string;
  }
  return loser_;
}
inline ::std::string* SCMsgGameEndNtf::release_loser() {
  clear_has_loser();
  if (loser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loser_;
    loser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SCMsgGameEndNtf::set_allocated_loser(::std::string* loser) {
  if (loser_ != &::google::protobuf::internal::kEmptyString) {
    delete loser_;
  }
  if (loser) {
    set_has_loser();
    loser_ = loser;
  } else {
    clear_has_loser();
    loser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSMsgPutBlockReq

// required int32 blockid = 1;
inline bool CSMsgPutBlockReq::has_blockid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMsgPutBlockReq::set_has_blockid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMsgPutBlockReq::clear_has_blockid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMsgPutBlockReq::clear_blockid() {
  blockid_ = 0;
  clear_has_blockid();
}
inline ::google::protobuf::int32 CSMsgPutBlockReq::blockid() const {
  return blockid_;
}
inline void CSMsgPutBlockReq::set_blockid(::google::protobuf::int32 value) {
  set_has_blockid();
  blockid_ = value;
}

// required int32 column = 2;
inline bool CSMsgPutBlockReq::has_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMsgPutBlockReq::set_has_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMsgPutBlockReq::clear_has_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMsgPutBlockReq::clear_column() {
  column_ = 0;
  clear_has_column();
}
inline ::google::protobuf::int32 CSMsgPutBlockReq::column() const {
  return column_;
}
inline void CSMsgPutBlockReq::set_column(::google::protobuf::int32 value) {
  set_has_column();
  column_ = value;
}

// -------------------------------------------------------------------

// CSMsgClearBlockReq

// repeated int32 rows = 1;
inline int CSMsgClearBlockReq::rows_size() const {
  return rows_.size();
}
inline void CSMsgClearBlockReq::clear_rows() {
  rows_.Clear();
}
inline ::google::protobuf::int32 CSMsgClearBlockReq::rows(int index) const {
  return rows_.Get(index);
}
inline void CSMsgClearBlockReq::set_rows(int index, ::google::protobuf::int32 value) {
  rows_.Set(index, value);
}
inline void CSMsgClearBlockReq::add_rows(::google::protobuf::int32 value) {
  rows_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CSMsgClearBlockReq::rows() const {
  return rows_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CSMsgClearBlockReq::mutable_rows() {
  return &rows_;
}

// -------------------------------------------------------------------

// SCMsgPutBlockNtf

// required int32 blockid = 1;
inline bool SCMsgPutBlockNtf::has_blockid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SCMsgPutBlockNtf::set_has_blockid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SCMsgPutBlockNtf::clear_has_blockid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SCMsgPutBlockNtf::clear_blockid() {
  blockid_ = 0;
  clear_has_blockid();
}
inline ::google::protobuf::int32 SCMsgPutBlockNtf::blockid() const {
  return blockid_;
}
inline void SCMsgPutBlockNtf::set_blockid(::google::protobuf::int32 value) {
  set_has_blockid();
  blockid_ = value;
}

// required int32 column = 2;
inline bool SCMsgPutBlockNtf::has_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SCMsgPutBlockNtf::set_has_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SCMsgPutBlockNtf::clear_has_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SCMsgPutBlockNtf::clear_column() {
  column_ = 0;
  clear_has_column();
}
inline ::google::protobuf::int32 SCMsgPutBlockNtf::column() const {
  return column_;
}
inline void SCMsgPutBlockNtf::set_column(::google::protobuf::int32 value) {
  set_has_column();
  column_ = value;
}

// -------------------------------------------------------------------

// SCMsgClearBlockNtf

// repeated int32 rows = 1;
inline int SCMsgClearBlockNtf::rows_size() const {
  return rows_.size();
}
inline void SCMsgClearBlockNtf::clear_rows() {
  rows_.Clear();
}
inline ::google::protobuf::int32 SCMsgClearBlockNtf::rows(int index) const {
  return rows_.Get(index);
}
inline void SCMsgClearBlockNtf::set_rows(int index, ::google::protobuf::int32 value) {
  rows_.Set(index, value);
}
inline void SCMsgClearBlockNtf::add_rows(::google::protobuf::int32 value) {
  rows_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SCMsgClearBlockNtf::rows() const {
  return rows_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SCMsgClearBlockNtf::mutable_rows() {
  return &rows_;
}

// -------------------------------------------------------------------

// SCMsgRoomInfoNtf

// repeated .sglib.publicproto.RoomPlayerInfo players = 1;
inline int SCMsgRoomInfoNtf::players_size() const {
  return players_.size();
}
inline void SCMsgRoomInfoNtf::clear_players() {
  players_.Clear();
}
inline const ::sglib::publicproto::RoomPlayerInfo& SCMsgRoomInfoNtf::players(int index) const {
  return players_.Get(index);
}
inline ::sglib::publicproto::RoomPlayerInfo* SCMsgRoomInfoNtf::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::sglib::publicproto::RoomPlayerInfo* SCMsgRoomInfoNtf::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sglib::publicproto::RoomPlayerInfo >&
SCMsgRoomInfoNtf::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::sglib::publicproto::RoomPlayerInfo >*
SCMsgRoomInfoNtf::mutable_players() {
  return &players_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tetrisproto
}  // namespace sglib

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tetris_2eproto__INCLUDED
